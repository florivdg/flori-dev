---
title: "Deno 2: It's Time To Switch"
pubDate: 2024-11-28
description: "Deno has the best foundation for the future. It's built on web standards like promises, fetch() or ES modules. This, combined with the fact that it's ecosystem is now more mature than ever and dependency management is actually fun, makes Deno the best choice for mission-critical applications."
image:
  {
    src: '../../assets/reads/deno-2.jpg',
    alt: 'Two cute dinosaur characters in neon blue and orange hues, facing each other in a digital, wireframe style, with glowing lights against a dark background.',
  }
tags: ["Deno", "TypeScript", "JavaScript", "Bun", "Node.js"]
---

import Image from '../../components/reads/Image.astro'
import Note from '../../components/reads/Note.astro'
import coverImage from '../../assets/reads/deno-2.jpg'

This may not be the right question to ask, but I wanted to see what **Deno 2** brings to the table. I've been using **Bun** lately, and I love the whole experience of it. But for **mission critical applications**, Deno is still the better choice due to its majurity. But let's face it, Bun is way more fun. So let's dive into the current state of Deno and see if it's shinier than ever... or not. üßê

<Image
  src={coverImage}
  alt='Two cute dinosaur characters in neon blue and orange hues, facing each other in a digital, wireframe style, with glowing lights against a dark background.'
  caption="Shinier Than Ever: Deno 2"
  lazy={false}
/>

## What I Didn't Like about Deno

Back in the Deno 1.x days, it was my go-to JavaScript runtime when it came to **performance, stability and security**. I would always prefer it over Node.js for my mission critical applications. Seeing Deno powering **Supabase Edge Functions** was amazing and I liked their integration a lot. Deno was the runtime that I would **recommend to my colleagues**. But still, there were some things that I didn't like about Deno.

- Direct URL imports were **confusing** and **hard to maintain**.
- Handling dependency upgrades was **messy** and **time-consuming**.
- The ecosystem was **not mature enough** and a lot of packages were **missing**.
- A lot of popular npm packages were **not available** in Deno.
- Buying into Deno was a **big commitment** and it was **hard to switch back** to Node.js.

It's been a while since I've used Deno. So let's see what the Deno 2 experience is like.

## Setting Up a Deno Project

What I really like is that you now have a `deno init` command to initialize a new Deno project. It gives you a nice projecture structure and there is a `deno.json` file that holds tasks (similar to npm scripts) and maps module imports.

## Dependency Management

### Adding Dependencies

Like with npm, you now can **add dependencies** to your project using the `deno add` command from the command line. It gets added to the `deno.json` file and there is even a `deno.lock` file that locks the versions of your dependencies. The **full-on `package.json` experience** like with npm or Bun is now available in Deno! üéâ

<Note>**‚òùÔ∏è Good To Know:** Deno supports `package.json` files out of the box for better Node compatibility.</Note>

You can still use **module imports from URLs**, but they now support installing **npm packages** and the Deno team has even built **[JSR](https://jsr.io), a TypeScript-native package registry** that on the flip side can also be used with npm, pnpm, and the like. Amazing! üëè

### Updating Dependencies

You can list outdated dependencies with `deno outdated` and update them with `deno outdated --update`. This is a **huge improvement** over the Deno 1.x days and makes dependency management a breeze.

No more fiddling around with `deps.ts` files and manual version updates or import maps. üòé

## Ecosystem

As mentioned before Deno 2 is **fully compatible with npm** and you can use npm packages in your Deno projects out of the box. It also is fully Node.js compatible and even things like Next.js are now supported.

For me personally, packages like `puppeteer` and the fact that I can run Astro with Deno are a huge win. With the stabilized [standard library](https://jsr.io/@std) and the new JSR registry, the Deno ecosystem is now more mature than ever.

## The All-in-One Solution

What I really like about Deno is that **it has everything you need** to build a modern web application. Deno 2 is a JavaScript runtime with native **TypeScript** support, a package manager, a test runner, a formatter, and a linter.

It has the **professional feel** that makes Golang or Rust so appealing. They both also have a top-notch tooling experience and come with batteries. Deno is no different, and it's a joy to work with.

## The Base for the Future

For me, and this is without a doubt the most interesting part, Deno has **the best foundation for the future**. It's built on **web standards** like promises, fetch() or ES modules. This, combined with the fact that it's **ecosystem is now more mature** than ever and **dependency management is actually fun**, makes Deno the best choice for mission-critical applications.